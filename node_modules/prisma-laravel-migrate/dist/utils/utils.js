import { MigrationTypes } from "../generator/migrator/migrationTypes.js";
import { NativeToMigrationTypeMap, PrismaTypes } from "../generator/migrator/column-maps.js";
/**
 * Given a Prisma field default, return the PHP code fragment
 * to append to your migration column definition.
 *
 * You’ll need to have `use Illuminate\Support\Facades\DB;`
 * at the top of your migration stub for the `DB::raw()` calls.
 */
export function formatDefault(field, defaultMaps) {
    const def = field.default;
    // No default → nothing to append
    if (def == null) {
        return "";
    }
    // 1) if there's a custom function, call it
    if (typeof def === "object" && "name" in def) {
        const fn = defaultMaps[def.name];
        if (fn) {
            const snippet = fn(field);
            // ensure we return leading `->`
            return snippet.startsWith("->") ? snippet : `->${snippet}`;
        }
    }
    // Prisma‐built functions
    if (typeof def === "object" && "name" in def) {
        const { name, args } = def;
        switch (name) {
            case "autoincrement":
                // already handled by getType()
                return "";
            case "dbgenerated":
                // DB‐generated expression
                const expr = args[0] ?? "";
                return `->default(DB::raw(${JSON.stringify(expr)}))`;
            case "sequence":
                // CockroachDB sequences
                // if sequence name passed → use that, otherwise guess "<column>_seq"
                const seqName = args[0] ?? `${field.name}_seq`;
                return `->default(DB::raw("nextval('${seqName}')"))`;
            case "now":
                // Laravel’s built‐in CURRENT_TIMESTAMP shorthand
                return "->useCurrent()";
            case "cuid":
            case "ulid":
            case "nanoid":
                // No first‐class DB functions, so emit raw call
                return `->default(DB::raw('${name}()'))`;
            case "uuid":
                // Postgres: gen_random_uuid(); MySQL: UUID()
                return `->default(DB::raw('gen_random_uuid()'))`;
            // Prisma also has sequence(), cuid(2), uuid(4/7) etc.
            // we ignore args for those variants and emit same DB call
        }
    }
    // Static literal defaults (numbers or strings)
    // e.g. →default(4), →default("hello")
    return `->default(${JSON.stringify(def)})`;
}
const intTypes = [PrismaTypes.BigInt, PrismaTypes.Int, PrismaTypes.UnsignedBigInt, PrismaTypes.UnsignedInt];
export function getType(field) {
    const { name, type: prismaType, nativeType, default: def, kind, isId, isList } = field;
    if (isList)
        return MigrationTypes.json;
    // 1. Only map a true auto-increment PK called "id" to Laravel's id()
    if (name === "id" &&
        kind === "scalar" &&
        intTypes.includes(prismaType) &&
        isId &&
        def?.name === "autoincrement") {
        return MigrationTypes.id;
    }
    // 2. Other @default(autoincrement()) fields
    if (def?.name === "autoincrement") {
        return prismaType === PrismaTypes.BigInt
            ? MigrationTypes.bigIncrements
            : MigrationTypes.increments;
    }
    // 3. Char-length UUID/ULID shortcuts
    if (prismaType === PrismaTypes.String && (nativeType?.[0] === PrismaTypes.Char || nativeType?.[0] === PrismaTypes.Binary)) {
        const len = Number(nativeType[1]?.[0]);
        if (len === 36)
            return MigrationTypes.uuid;
        if (len === 26)
            return MigrationTypes.ulid;
    }
    // 4. Fallback to your nativeType/prismaType lookup
    const key = nativeType?.[0] ?? prismaType;
    // @ts-ignore
    return NativeToMigrationTypeMap[key] ?? MigrationTypes.string;
}
/**
 * Escape a stub’s contents so it can be safely wrapped in a JS template literal.
 * This will:
 *  - Escape all backslashes
 *  - Escape all backticks
 */
export function formatStub(stub) {
    return stub;
}
/** tx_ + users + _tx → returns "tx_users_tx" */
export function decorate(name, opts) {
    const pre = opts.tablePrefix ?? "";
    const suf = opts.tableSuffix ?? "";
    return `${pre}${name}${suf}`.trim();
}
export function addToConfig(key, value) {
    global._config = global._config ?? {};
    global._config[key] = value;
}
export { resolveStub } from './stubResolver.js';
export { stripDirectives } from './clean.js';
// Impl
export function getConfig(key, property) {
    const cfg = (global._config ?? {});
    const section = cfg[key];
    return property ? section?.[property] : section;
}
// Shared flags for both directives
export var GenTarget;
(function (GenTarget) {
    GenTarget[GenTarget["None"] = 0] = "None";
    GenTarget[GenTarget["Model"] = 1] = "Model";
    GenTarget[GenTarget["Migrator"] = 2] = "Migrator";
})(GenTarget || (GenTarget = {}));
export const isForModel = (t) => (t & GenTarget.Model) !== 0;
export const isForMigrator = (t) => (t & GenTarget.Migrator) !== 0;
/**
 * Generic parser for @local / @silent
 * Forms supported:
 *   @<tag>                         → defaultFlags
 *   @<tag>(model)                  → Model
 *   @<tag>(migrator|migration)     → Migrator
 *   @<tag>(both|all|*)             → Model|Migrator
 *   @<tag>(model,migrator)         → Model|Migrator
 * Last occurrence wins if multiple appear.
 */
export function parseTargetDirective(tag, doc, defaultFlags = GenTarget.Model) {
    if (!doc)
        return GenTarget.None;
    const rx = new RegExp(`@${tag}(?:\\s*\\(([^)]*)\\))?`, 'gi');
    let m;
    let lastArgs;
    let saw = false;
    while ((m = rx.exec(doc))) {
        saw = true;
        lastArgs = (m[1] ?? '').trim();
    }
    if (!saw)
        return GenTarget.None;
    if (!lastArgs)
        return defaultFlags;
    const parts = lastArgs
        .split(/[,\s]+/)
        .map(s => s.trim().toLowerCase())
        .filter(Boolean);
    let flags = GenTarget.None;
    for (const p of parts) {
        if (p === 'model' || p === 'models' || p === 'modeler') {
            flags |= GenTarget.Model;
        }
        else if (p === 'migrator' || p === 'migration' || p === 'migrations') {
            flags |= GenTarget.Migrator;
        }
        else if (p === 'both' || p === 'all' || p === '*') {
            flags |= GenTarget.Model | GenTarget.Migrator;
        }
    }
    return flags === GenTarget.None ? defaultFlags : flags;
}
// Convenience wrappers with their defaults:
// @local           → Model
// @silent          → Model|Migrator
export const parseLocalDirective = (doc) => parseTargetDirective('local', doc, GenTarget.Model);
export const parseSilentDirective = (doc) => parseTargetDirective('silent', doc, GenTarget.Model | GenTarget.Migrator);
export const listFrom = (doc, tag) => {
    const out = [];
    // @tag{ ... }
    const braceRe = new RegExp(`@${tag}\\{([\\s\\S]*?)\\}`, "gi");
    for (let m; (m = braceRe.exec(doc));)
        out.push(...m[1].split(","));
    // @tag( ... )
    const parenRe = new RegExp(`@${tag}\\(([^)]*)\\)`, "gi");
    for (let m; (m = parenRe.exec(doc));)
        out.push(...m[1].split(","));
    // @tag: a,b,c   (until newline)
    const colonRe = new RegExp(`@${tag}\\s*:\\s*([^\\r\\n]+)`, "gi");
    for (let m; (m = colonRe.exec(doc));)
        out.push(...m[1].split(","));
    // normalize
    const seen = new Set();
    const cleaned = [];
    for (const s of out.map(x => x.trim()).filter(Boolean)) {
        if (!seen.has(s)) {
            seen.add(s);
            cleaned.push(s);
        }
    }
    return cleaned;
};
//# sourceMappingURL=utils.js.map