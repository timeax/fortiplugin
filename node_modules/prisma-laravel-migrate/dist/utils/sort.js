/**
 * Reorders migrations so that any table with foreignâ€key dependencies
 * is always migrated *after* the tables it references.
 */
export function sortMigrations(migrations) {
    // â¬…ï¸ NEW: drop migrations silenced for the migrator
    migrations = migrations.filter(m => !m.local);
    // 1) Build a map: tableName â†’ Migration
    const migMap = new Map(migrations.map(m => [m.name, m]));
    // 2) Collect â€œtrueâ€ FKs only (skip backâ€relation object fields)
    const rawDeps = new Map();
    for (const { name: tableName } of migrations) {
        rawDeps.set(tableName, new Set());
    }
    for (const m of migrations) {
        for (const def of m.definitions) {
            // â¬…ï¸ NEW: skip FK edges silenced at column level
            if (def.local)
                continue;
            // owning side: has relationFromFields
            if (!def.relationship ||
                !def.relationFromFields ||
                def.relationFromFields.length === 0) {
                continue;
            }
            const parent = def.relationship.on;
            if (!migMap.has(parent) || m.name === parent)
                continue; // skip external/self
            rawDeps.get(m.name).add(parent);
        }
    }
    // 3) Build adjacency (parent â†’ dependents) and in-degree (table â†’ count)
    const adj = new Map();
    const inDegree = new Map();
    for (const tbl of migMap.keys()) {
        adj.set(tbl, []);
        inDegree.set(tbl, 0);
    }
    for (const [child, parents] of rawDeps) {
        for (const parent of parents) {
            if (parent !== child)
                adj.get(parent).push(child);
            inDegree.set(child, inDegree.get(child) + 1);
        }
    }
    // 4) Kahnâ€™s algorithm
    const queue = [];
    for (const [tbl, deg] of inDegree)
        if (deg === 0)
            queue.push(tbl);
    const sorted = [];
    while (queue.length) {
        const tbl = queue.shift();
        sorted.push(migMap.get(tbl));
        for (const child of adj.get(tbl)) {
            const nd = inDegree.get(child) - 1;
            inDegree.set(child, nd);
            if (nd === 0)
                queue.push(child);
        }
    }
    // 5) Cycle check
    if (sorted.length !== migrations.length) {
        const cycle = migrations
            .map(m => m.name)
            .filter(t => !sorted.some(s => s.name === t));
        throw new Error(`Cycle detected in migration dependencies: ${cycle.join(' â†’ ')}`);
    }
    console.log('\nðŸ“¦ Sorted Migration Tables:\n' +
        sorted.map((item, i) => ` ${i + 1}. ${item.tableName}`).join('\n') +
        '\n');
    return sorted;
}
//# sourceMappingURL=sort.js.map