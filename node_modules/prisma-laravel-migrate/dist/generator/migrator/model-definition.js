export function buildCompositeFromIndexes(model) {
    const raw = (model.indexes ?? []);
    const isComposite = (i) => Array.isArray(i.fields) && i.fields.length > 1 && i.isDefinedOnField !== true;
    const isPk = (i) => {
        const t = (i.type || "").toLowerCase();
        return t === "id" || t === "primary";
    };
    const isUnique = (i) => (typeof i.type === "string" && i.type.toLowerCase() === "unique") || i.isUnique === true;
    const uniques = [];
    const normals = [];
    for (const i of raw) {
        if (!isComposite(i) || isPk(i))
            continue;
        const spec = { fields: i.fields, name: i.name };
        (isUnique(i) ? uniques : normals).push(spec);
    }
    // de-dupe by ordered field list (ignore name for dedupe)
    const dedupe = (xs) => {
        const seen = new Set();
        return xs.filter(x => {
            const key = x.fields.join("|");
            if (seen.has(key))
                return false;
            seen.add(key);
            return true;
        });
    };
    return {
        ...model,
        compositeUniques: dedupe(uniques),
        compositeNormals: dedupe(normals),
    };
}
/** Optional: build for all models in a DMMF document */
export function buildAllCompositeFromIndexes(doc) {
    const out = {};
    for (const m of doc.datamodel.models)
        out[m.name] = buildCompositeFromIndexes(m);
    return out;
}
//# sourceMappingURL=model-definition.js.map