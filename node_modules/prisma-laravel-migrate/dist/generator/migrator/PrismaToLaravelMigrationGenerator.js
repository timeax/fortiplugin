import { ColumnDefinitionGenerator } from "./column-definition.js";
import { RuleResolver } from "./rule-definition.js";
import { isForMigrator, parseSilentDirective } from "../../utils/utils.js";
export class PrismaToLaravelMigrationGenerator {
    dmmf;
    columnGen;
    ruleResolver;
    constructor(dmmf, customRules = [], defaultMaps = {}) {
        this.dmmf = dmmf;
        this.columnGen = new ColumnDefinitionGenerator(dmmf);
        this.ruleResolver = new RuleResolver(dmmf, customRules, defaultMaps);
    }
    /**
     * Given an array of ColumnDefinition, apply rules and return PHP snippets.
     * Skips any definitions marked `ignore = true`.
     */
    resolveColumns(defs) {
        // give the resolver full context for this model
        this.ruleResolver.setDefinitions(defs);
        /* ---------- 1. per-column rules (two-step flatMap) ------------------ */
        const columnLines = defs
            .flatMap(def => {
            // step-1: run the rule, keep def so we can see flags it sets
            const { snippet } = this.ruleResolver.resolve(def);
            return { def, snippet };
        })
            .flatMap(({ def, snippet }) => {
            // step-2: honour any def.ignore set by the rule
            return def.ignore ? [] : snippet;
        });
        /* ---------- 2. table-level utilities (PK, indexes, …) --------------- */
        const utilityLines = this.ruleResolver.resolveUtilities();
        /* ---------- 3. combine: columns first, utilities last --------------- */
        return [...columnLines, ...utilityLines];
    }
    /**
     * Generate a Migration object for each model, using per‐model definitions.
     */
    generateAll() {
        // 1) Build a map: modelName → DMMF.Index[]
        const indexMap = new Map();
        for (const idx of this.dmmf.datamodel.indexes) {
            if (!idx.isDefinedOnField) {
                const arr = indexMap.get(idx.model) ?? [];
                arr.push(idx);
                indexMap.set(idx.model, arr);
            }
        }
        // 2) For each model, resolve columns + utilities
        return this.dmmf.datamodel.models.map(model => {
            const modelName = model.name;
            const tableName = model.dbName ?? modelName;
            // a) Get your column definitions
            const definitions = this.columnGen.getColumns(tableName);
            // b) Resolve each column’s snippets
            const columns = this.resolveColumns(definitions);
            // c) Grab the Prisma @@index/@@unique/@@id entries for this model
            const indexes = indexMap.get(modelName) ?? [];
            // d) Build the table-level utilities and append them *after* the columns
            const utilities = this.buildTableUtilities(indexes);
            // e) Check for @silent tag in model docblock
            const isSilent = isForMigrator(parseSilentDirective(model.documentation ?? ""));
            return {
                tableName,
                isIgnored: isSilent,
                local: isSilent,
                definitions,
                statements: [...columns, ...utilities],
            };
        });
    }
    /**
       * Build table-level helpers (composite PK / composite & multi-col indexes / unique fields).
       *
       * @param indexes  The Prisma DMMF.Index[] *for this model only*.
       *                 Note `indexes` are all where isDefinedOnField is false.
       */
    buildTableUtilities(indexes = []) {
        const out = [];
        /**
          end products should fit Laravel’s Schema builder:
            $table->primary($columns, $name = null, $algorithm = null);
            $table->index($columns,   $name = null, $algorithm = null);
            $table->unique($columns,  $name = null, $algorithm = null);
          where $columns is string or string[]
        */
        /* ── 1️⃣  Primary keys ─────────────────────────────────────────── */
        const primaryIdxs = indexes.filter(i => i.type === "id");
        primaryIdxs.forEach(idx => {
            const parts = [];
            // open call
            parts.push("$table->primary(");
            // columns
            if (idx.fields.length > 1) {
                const cols = idx.fields.map(f => `'${f.name}'`).join(", ");
                parts.push(`[${cols}]`);
            }
            else {
                parts.push(`'${idx.fields[0].name}'`);
            }
            // name
            if (idx.name) {
                parts.push(`, '${idx.name}'`);
            }
            // algorithm
            if (idx.algorithm) {
                parts.push(`, '${idx.algorithm}'`);
            }
            // close
            parts.push(");");
            out.push(parts.join(""));
        });
        /* ── 2️⃣  Composite indexes ───────────────────────────────────── */
        const indexIdxs = indexes.filter(i => i.type === "normal");
        // (a) Composite
        indexIdxs.filter(i => i.fields.length > 1)
            .forEach(idx => {
            const parts = ["$table->index("];
            const cols = idx.fields.map(f => `'${f.name}'`).join(", ");
            parts.push(`[${cols}]`);
            if (idx.name)
                parts.push(`, '${idx.name}'`);
            if (idx.algorithm)
                parts.push(`, '${idx.algorithm}'`);
            parts.push(");");
            out.push(parts.join(""));
        });
        // (b) Single
        indexIdxs.filter(i => i.fields.length === 1)
            .forEach(idx => {
            const parts = ["$table->index("];
            parts.push(`'${idx.fields[0].name}'`);
            if (idx.name)
                parts.push(`, '${idx.name}'`);
            if (idx.algorithm)
                parts.push(`, '${idx.algorithm}'`);
            parts.push(");");
            out.push(parts.join(""));
        });
        /* ── 3️⃣  Composite unique keys ───────────────────────────────── */
        const uniqueIdxs = indexes.filter(i => i.type === "unique");
        // (a) Composite
        uniqueIdxs.filter(i => i.fields.length > 1)
            .forEach(idx => {
            const parts = ["$table->unique("];
            const cols = idx.fields.map(f => `'${f.name}'`).join(", ");
            parts.push(`[${cols}]`);
            if (idx.name)
                parts.push(`, '${idx.name}'`);
            if (idx.algorithm)
                parts.push(`, '${idx.algorithm}'`);
            parts.push(");");
            out.push(parts.join(""));
        });
        // (b) Single
        uniqueIdxs.filter(i => i.fields.length === 1)
            .forEach(idx => {
            const parts = ["$table->unique("];
            parts.push(`'${idx.fields[0].name}'`);
            if (idx.name)
                parts.push(`, '${idx.name}'`);
            if (idx.algorithm)
                parts.push(`, '${idx.algorithm}'`);
            parts.push(");");
            out.push(parts.join(""));
        });
        /* -----------------------------------------------------------
        * 2️⃣  Prisma model‐level FULLTEXT indexes
        * --------------------------------------------------------- */
        for (const idx of indexes.filter(i => i.type === 'fulltext')) {
            // Composite fullText: multiple columns
            if (idx.fields.length > 1) {
                const cols = idx.fields.map(f => `'${f.name}'`).join(', ');
                const name = idx.name ? `, '${idx.name}'` : '';
                const algo = idx.algorithm ? `, '${idx.algorithm}'` : '';
                out.push(`$table->fullText([${cols}]${name}${algo});`);
            }
            // Single‐column fullText
            else if (idx.fields.length === 1) {
                const col = idx.fields[0].name;
                const name = idx.name ? `, '${idx.name}'` : '';
                const algo = idx.algorithm ? `, '${idx.algorithm}'` : '';
                out.push(`$table->fullText('${col}'${name}${algo});`);
            }
        }
        return out;
    }
}
//# sourceMappingURL=PrismaToLaravelMigrationGenerator.js.map