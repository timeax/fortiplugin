import fs from "fs";
import path from "path";
import { formatStub, resolveStub, decorate, // ⬅️ helper that applies prefix / suffix
 } from "../utils/utils.js";
import { sortMigrations } from "../utils/sort.js";
export class StubMigrationPrinter {
    cfg;
    globalStubPath;
    #currentStubPath = "";
    tmplFn;
    static textCache = new Map();
    constructor(
    /** base config for per-table stub resolution */
    cfg, 
    /** optional global override: if set, always use this stub */
    globalStubPath) {
        this.cfg = cfg;
        this.globalStubPath = globalStubPath;
    }
    /** Switch to the correct stub for this table (or reuse the last one) */
    ensureStub(tableName) {
        /* 1) choose stub path */
        const resolved = resolveStub(this.cfg, "migration", tableName);
        const stubPath = resolved
            ? resolved
            : this.globalStubPath
                ? path.resolve(process.cwd(), this.globalStubPath)
                : (() => {
                    throw new Error(`No stub found for migration '${tableName}'`);
                })();
        if (stubPath === this.#currentStubPath)
            return;
        /* 2) compile template */
        let raw = StubMigrationPrinter.textCache.get(stubPath);
        if (!raw) {
            raw = fs.readFileSync(stubPath, "utf-8");
            StubMigrationPrinter.textCache.set(stubPath, raw);
        }
        this.tmplFn = new Function("tableName", "columns", "definitions", `return \`${formatStub(raw)}\`;`);
        this.#currentStubPath = stubPath;
    }
    /**
     * Render a single migration.
     * Returns both the full file and the raw column block.
     */
    printMigration(mig) {
        this.ensureStub(mig.tableName);
        const columns = mig.statements
            .map((l) => "            " + l)
            .join("\n");
        /* apply prefix/suffix when inserting into the stub */
        const physicalTable = decorate(mig.tableName, this.cfg);
        const fullContent = this.tmplFn(physicalTable, columns, mig.definitions);
        return { fullContent, columns };
    }
    /** Render all migrations, sorted */
    printAll(migs) {
        return sortMigrations(migs)
            .map((m) => this.printMigration(m).fullContent)
            .join("\n\n");
    }
}
//# sourceMappingURL=migrations.js.map