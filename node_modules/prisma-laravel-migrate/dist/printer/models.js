import fs from 'fs';
import path from 'path';
import { decorate, formatStub, resolveStub } from '../utils/utils.js';
import { relationTemplate } from '../generator/modeler/relationship/template-builder.js';
/**
 * Loads JS‐based stubs for both models and enums, and evaluates
 * their `${…}` placeholders at runtime.
 *
 * Stub‐resolution precedence:
 *  1) per‐table/group/index via resolveStub()
 *  2) global override (if provided)
 *  3) error
 */
export class StubModelPrinter {
    cfg;
    globalModelStub;
    globalEnumStub;
    // caches for current stub paths
    #currentModelStub = '';
    #currentEnumStub = '';
    // compiled template functions
    modelTmpl;
    enumTmpl;
    constructor(
    /** stubDir + groups config */
    cfg, 
    /** global override for all models */
    globalModelStub, 
    /** global override for all enums */
    globalEnumStub) {
        this.cfg = cfg;
        this.globalModelStub = globalModelStub;
        this.globalEnumStub = globalEnumStub;
    }
    /** Render a single enum class. */
    printEnum(enumDef) {
        this.ensureEnumStub(enumDef.name);
        return this.enumTmpl(enumDef);
    }
    /** Render multiple enums, separated by two newlines. */
    printAllEnums(enums) {
        return enums.map(e => this.printEnum(e)).join('\n\n');
    }
    /** Render a single model class with injected `content`. */
    printModel(model, enums, content) {
        this.ensureModelStub(model.tableName);
        //--
        model.tableName = decorate(model.tableName, this.cfg);
        const docblock = [
            '/**',
            ...model.docblockProps?.map(p => ` * ${p}`) ?? [],
            ' */'
        ].join('\n');
        //--
        return this.modelTmpl(model, enums, content, docblock, {
            toString() {
                return model.relations
                    .map(r => relationTemplate(r, { useCompoships: true }))
                    .join('\n\n');
            }
        });
    }
    /** Render multiple models, each with its own `content`, separated by two newlines. */
    printAllModels(models, enums, contents) {
        return models
            .map((m, i) => this.printModel(m, enums, contents[i]))
            .join('\n\n');
    }
    /** Render enums first, then models, joined by two newlines. */
    printAll(models, enums, contents) {
        const outEnums = this.printAllEnums(enums);
        const outModels = this.printAllModels(models, enums, contents);
        return [outEnums, outModels].filter(Boolean).join('\n\n');
    }
    /** Load & compile the correct model stub for `tableName`. */
    ensureModelStub(tableName) {
        // 1) try per‐table/group/index
        const resolved = resolveStub(this.cfg, 'model', tableName);
        // 2) fall back to globalModelStub if none found
        const stubPath = resolved
            ? resolved
            : this.globalModelStub
                ? path.resolve(process.cwd(), this.globalModelStub)
                : (() => { throw new Error(`No stub found for model '${tableName}'`); })();
        if (stubPath === this.#currentModelStub)
            return;
        const raw = fs.readFileSync(path.resolve(stubPath), 'utf-8').trim();
        this.modelTmpl = new Function('model', 'enums', 'content', 'docblock', 'relationships', `return \`${formatStub(raw)}\`;`);
        this.#currentModelStub = stubPath;
    }
    /** Load & compile the correct enum stub for `enumDef.name`. */
    ensureEnumStub(name) {
        // 1) try per‐enum/group/index
        const resolved = resolveStub(this.cfg, 'enum', name);
        // 2) fall back to globalEnumStub if none found
        const stubPath = resolved
            ? resolved
            : this.globalEnumStub
                ? path.resolve(process.cwd(), this.globalEnumStub)
                : (() => {
                    throw new Error(`No stub found for enum '${name}'`);
                })();
        if (stubPath === this.#currentEnumStub)
            return;
        const raw = fs.readFileSync(path.resolve(stubPath), 'utf-8').trim();
        this.enumTmpl = new Function('enumDef', `return \`${formatStub(raw)}\`;`);
        this.#currentEnumStub = stubPath;
    }
}
//# sourceMappingURL=models.js.map