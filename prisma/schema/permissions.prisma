/// ===========================
/// Polymorphic enum
/// ===========================
enum PermissionType {
  db
  file
  notification
  module
  network
  codec // obfuscator
}

/// ===========================
/// Route approval enum (as you defined)
/// ===========================
enum RoutePermissionStatus {
  pending
  approved
  denied
  revoked
}

/// ===========================
/// Optional bundles (tags)
/// ===========================

///@guarded:id
///@fillable:name,description,is_system,status
model PermissionTag {
  id          BigInt       @id @default(autoincrement()) @db.BigInt
  name        String       @unique
  description String?
  is_system   Boolean      @default(false)
  status      PluginStatus @default(active)
  created_at  DateTime     @default(now())
  updated_at  DateTime     @updatedAt

  // assignments
  plugins PluginPermissionTag[]
  items   PermissionTagItem[]

  @@map("permission_tags")
}

/// Assign a tag to a plugin (plugins inherit all tag items)
/// Host can time-window the entire tag assignment.
///@guarded:id
///@fillable:plugin_id,tag_id,active,limited,limit_type,limit_value
model PluginPermissionTag {
  id        BigInt  @id @default(autoincrement()) @db.BigInt
  plugin_id BigInt
  tag_id    BigInt
  active    Boolean @default(true)

  // Host-only approval window (not from manifest)
  limited     Boolean @default(false)
  limit_type  String?
  limit_value String?

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  plugin Plugin        @relation(fields: [plugin_id], references: [id])
  tag    PermissionTag @relation(fields: [tag_id], references: [id])

  @@unique([plugin_id, tag_id])
  @@index([plugin_id])
  @@index([tag_id])
  @@map("plugin_permission_tags")
}

/// Tag → Concrete permission (polymorphic)
/// Allows per-item constraints/audit at the tag layer.
///@guarded:id
///@fillable:tag_id,permission_type,permission_id,constraints,audit
model PermissionTagItem {
  id              BigInt         @id @default(autoincrement()) @db.BigInt
  tag_id          BigInt
  permission_type PermissionType
  permission_id   BigInt         @db.BigInt

  // Assignment-level metadata (host managed)
  constraints Json?
  audit       Json?

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  tag PermissionTag @relation(fields: [tag_id], references: [id])

  @@unique([tag_id, permission_type, permission_id], map: "pti_tag_type_pid_unique", name: "pti_tag_type_pid_unique")
  @@index([tag_id])
  @@map("permission_tag_items")
}

/// ===========================
/// Direct plugin assignments
/// ===========================

/// Plugin → Concrete permission (polymorphic)
/// Includes constraints/audit at the direct assignment level.
///@guarded:id
///@fillable:plugin_id,permission_type,permission_id,active,limited,limit_type,limit_value,constraints,audit
model PluginPermission {
  id              BigInt         @id @default(autoincrement()) @db.BigInt
  plugin_id       BigInt
  permission_type PermissionType
  permission_id   BigInt         @db.BigInt
  active          Boolean        @default(false)

  // Host-only approval window (not from manifest)
  limited     Boolean @default(false)
  limit_type  String?
  limit_value String?

  // Assignment-level metadata (host managed)
  constraints Json?
  audit       Json?

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  plugin Plugin @relation(fields: [plugin_id], references: [id])

  @@unique([plugin_id, permission_type, permission_id])
  @@index([plugin_id])
  @@map("plugin_permissions")
}

/// ===========================
/// Concrete permissions (strict action parity)
/// ===========================

/// DB — actions: select, insert, update, delete, truncate, grouped_queries
///@guarded:id,permissions,natural_key
///@fillable:natural_key,model,table,readable_columns,writable_columns,limited,limit_type,limit_value
model DbPermission {
  id BigInt @id @default(autoincrement()) @db.BigInt

  /// Deterministic natural key (e.g., hash of model/table/columns/action-set)
  natural_key String @unique

  model String? // alias/FQCN (host-catalog validated if provided)
  table String? // optional raw table name

  // Boolean map: { select, insert, update, delete, truncate, grouped_queries }
  permissions Json // SERVICE-MANAGED

  readable_columns Json?
  writable_columns Json?

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@map("db_permissions")
}

/// FILE — actions: read, write, append, delete, mkdir, rmdir, list
///@guarded:id,permissions,natural_key
///@fillable:natural_key,base_dir,paths,limited,limit_type,limit_value
model FilePermission {
  id BigInt @id @default(autoincrement()) @db.BigInt

  /// Deterministic natural key (e.g., hash of base_dir/paths/action-set)
  natural_key String @unique

  base_dir String
  paths    Json // ["**/*","logs/*",...]

  // Boolean map: { read, write, append, delete, mkdir, rmdir, list }
  permissions Json // SERVICE-MANAGED

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@map("file_permissions")
}

/// NOTIFY — actions: send, receive
///@guarded:id,permissions,natural_key
///@fillable:natural_key,channel,templates_allowed,recipients_allowed,limited,limit_type,limit_value
model NotificationPermission {
  id BigInt @id @default(autoincrement()) @db.BigInt

  /// Deterministic natural key (e.g., hash of channel/templates/recipients/action-set)
  natural_key String @unique

  channel String // host-defined alias

  // Boolean map: { send, receive }
  permissions Json // SERVICE-MANAGED

  templates_allowed  Json?
  recipients_allowed Json?

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@map("notification_permissions")
}

/// MODULE — single action: call → access flag
///@guarded:id,natural_key
///@fillable:natural_key,module,apis,access,limited,limit_type,limit_value
model ModulePermission {
  id BigInt @id @default(autoincrement()) @db.BigInt

  /// Deterministic natural key (e.g., hash of module/apis)
  natural_key String @unique

  module String // alias or FQCN (host-catalog validated)
  apis   Json // ["createToken","revokeToken",...]
  access Boolean @default(false) // action: call

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@map("module_permissions")
}

/// NETWORK — single action: request → access flag
/// NOTE: natural key is `rule_key` (kept as-is).
///@guarded:id,rule_key
///@fillable:rule_key,label,hosts,methods,schemes,ports,paths,headers_allowed,ips_allowed,auth_via_host_secret,access,limited,limit_type,limit_value
model NetworkPermission {
  id BigInt @id @default(autoincrement()) @db.BigInt

  /// Deterministic fingerprint for this rule (e.g., sha1 over hosts/methods/schemes/ports/paths).
  natural_key String @unique

  /// Optional human-readable label for admins/reviewers.
  label String?

  /// Gate for network egress via the host HTTP client.
  access Boolean @default(false)

  /// Allowlists (manifest `target` fields)
  hosts           Json // ["api.stripe.com","*.example.com"]
  methods         Json // ["GET","POST"]
  schemes         Json?
  ports           Json?
  paths           Json?
  headers_allowed Json?
  ips_allowed     Json?

  /// Secrets policy: if true, the host injects credentials; plugins don't supply secrets.
  auth_via_host_secret Boolean @default(true)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@map("network_permissions")
}

/// CODEC/OBFUSCATOR — single action: invoke → access flag
///@guarded:id,natural_key
///@fillable:natural_key,module,allowed,access,limited,limit_type,limit_value
model CodecPermission {
  id BigInt @id @default(autoincrement()) @db.BigInt

  /// Deterministic natural key (e.g., hash of allowed+access)
  natural_key String @unique

  module  String  @default("codec")
  allowed Json? // validated against Obfuscator catalog
  access  Boolean @default(false) // action: invoke

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@map("codec_permissions")
}

/// ===========================
/// Per-route approvals (as provided)
/// ===========================

/// @fillable(plugin_id, route_id, status, guard, meta, approved_at)
model PluginRoutePermission {
  id        BigInt @id @default(autoincrement())
  plugin_id BigInt
  plugin    Plugin @relation(fields: [plugin_id], references: [id])

  /// The JSON-declared route `id` (unique per plugin).
  route_id String

  /// Current permission state.
  status RoutePermissionStatus @default(pending)

  /// Optional: lock the guard used when writing this route.
  guard String?

  /// Host-defined metadata (notes, expiresAt, reasons, etc.).
  meta Json?

  approved_at DateTime?
  created_at  DateTime  @default(now())
  updated_at  DateTime  @updatedAt

  @@unique([plugin_id, route_id])
  @@index([plugin_id, status])
  @@map("plugin_route_permissions")
}

/// ===========================
/// Plugin (links to pivots)
/// ===========================
/// NOTE: Assuming PluginStatus enum & other related models already exist.
///@guarded
model Plugin {
  id                    BigInt       @id @default(autoincrement()) @db.BigInt
  name                  String       @unique
  image                 String?
  status                PluginStatus @default(active)
  config                Json?
  meta                  Json?
  plugin_placeholder_id BigInt       @unique @db.BigInt
  active_version_id     BigInt
  owner_ref             String?

  // existing relations (assumed to exist)
  placeholder     PluginPlaceholder @relation(fields: [plugin_placeholder_id], references: [id])
  plugin_settings PluginSetting[]
  plugin_versions PluginVersion[]
  logs            PluginAuditLog[]
  authors         PluginAuthor[]
  issues          PluginIssue[]

  // direct + tag bundles
  plugin_permissions PluginPermission[]
  permission_tags    PluginPermissionTag[]

  // per-route approvals
  routes PluginRoutePermission[]

  activated_at DateTime?
  activated_by BigInt?

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@map("plugins")
}
