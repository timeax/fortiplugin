<?php /** @noinspection ALL */
#{SIGNATURE_BLOCK}

declare(strict_types=1);

namespace IGNORE;
#{PLUGIN_NAMESPACE}\Internal;

use Illuminate\Support\Arr;
use Illuminate\Support\Str;
use Timeax\FortiPlugin\Contracts\ConfigInterface;
use Timeax\FortiPlugin\Enums\PermissionType;
use Timeax\FortiPlugin\Enums\PluginSettingValueType;
use Timeax\FortiPlugin\Facades\Permissions;
use Timeax\FortiPlugin\Models\PluginSetting;
use Timeax\FortiPlugin\Permissions\Evaluation\Dto\PermissionListOptions;
use Timeax\FortiPlugin\Permissions\Evaluation\Dto\PermissionListResult;
use Timeax\FortiPlugin\Permissions\Evaluation\Dto\PermissionListSummary;
use Timeax\FortiPlugin\Permissions\Evaluation\Dto\Result;

final class Config implements ConfigInterface
{
    /**
     * Cached plugin config values – loaded from plugin.config.json (or fallback).
     * @var array<string,mixed>
     */
    private static array $configData = [];

    /**
     * Runtime installation info (e.g., from DB / installer).
     * These placeholders are replaced during install.
     * @var array{id:int|null,alias:string|null,name?:string|null}
     */
    private static array $info = [
        'id' => (int)'#{PLUGIN_ID}',
        'alias' => '#{PLUGIN_ALIAS}',
        'name' => '#{PLUGIN_STUDLY}',
    ];

    /** Cached signature contents from `.internal/Signed`. */
    private static ?string $signature = null;

    /** Manifest cache. */
    private static array $manifest = [];

    /* ───────────────────────────────────────────────────────────────
     |  Internal helpers (IO + tiny utilities)
     ─────────────────────────────────────────────────────────────── */

    /**
     * Load and cache manifest.json.
     *
     * @return array<string,mixed>
     */
    private static function loadManifest(): array
    {
        if (self::$manifest !== []) {
            return self::$manifest;
        }

        $path = dirname(__DIR__) . '/manifest.json';
        if (!is_file($path)) {
            return self::$manifest = [];
        }

        $json = @file_get_contents($path);
        $data = json_decode($json ?: 'null', true);
        return self::$manifest = is_array($data) ? $data : [];
    }

    /**
     * Load and cache plugin.config.json (with safe fallbacks).
     *
     * Order tried:
     *  - plugin.config.json
     *  - config.json
     *  - plugin.json
     *
     * @return array<string,mixed>
     */
    private static function loadConfig(): array
    {
        if (self::$configData !== []) {
            return self::$configData;
        }

        $root = dirname(__DIR__); // Internal/.. → plugin root
        $candidates = [
            $root . '/plugin.config.json',
            $root . '/config.json',
            $root . '/../fortiplugin.json',
        ];

        foreach ($candidates as $file) {
            if (is_file($file)) {
                $json = @file_get_contents($file);
                $arr = json_decode($json ?: 'null', true);
                if (is_array($arr)) {
                    return self::$configData = $arr;
                }
            }
        }

        return self::$configData = [];
    }

    /**
     * Dot-get helper over an array, with default.
     *
     * @template TDefault
     * @param array<string,mixed> $source
     * @param string $key
     * @param TDefault $default
     * @return mixed|TDefault
     */
    private static function arrayGet(array $source, string $key, mixed $default = null): mixed
    {
        if (array_key_exists($key, $source)) {
            return $source[$key];
        }
        $segments = \explode('.', $key);
        $cursor = $source;
        foreach ($segments as $seg) {
            if (is_array($cursor) && array_key_exists($seg, $cursor)) {
                $cursor = $cursor[$seg];
            } else {
                return $default;
            }
        }
        return $cursor;
    }

    /**
     * Decode a PluginSetting row to native PHP according to its type enum.
     */
    private static function decodeHostSetting(?PluginSetting $row, mixed $default): mixed
    {
        if (!$row) {
            return $default;
        }

        $type = $row->type; // enum PluginSettingValueType
        $raw = $row->value;

        return match ($type) {
            PluginSettingValueType::string => $raw,
            PluginSettingValueType::number => (Str::contains($raw, ['.', 'e', 'E']))
                ? (float)$raw
                : (int)$raw,
            PluginSettingValueType::boolean => filter_var($raw, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE) ?? $default,
            PluginSettingValueType::json => (static function () use ($raw, $default) {
                $decoded = json_decode($raw, true);
                return json_last_error() === JSON_ERROR_NONE ? $decoded : $default;
            })(),
            PluginSettingValueType::file,
            PluginSettingValueType::blob => $raw,
        };
    }

    /* ───────────────────────────────────────────────────────────────
     |  ConfigInterface – config & identity
     ─────────────────────────────────────────────────────────────── */

    /**
     * {@inheritdoc}
     */
    public static function all(): array
    {
        return self::loadConfig();
    }

    /**
     * {@inheritdoc}
     */
    public static function get(string $key, mixed $default = null): mixed
    {
        return self::arrayGet(self::all(), $key, $default);
    }

    /**
     * {@inheritdoc}
     */
    public static function getName(): string
    {
        $fromInfo = (string)(self::$info['name'] ?? '');
        return $fromInfo !== '' ? $fromInfo : (string)self::get('name', '#{PLUGIN_STUDLY}');
    }

    /**
     * {@inheritdoc}
     */
    public static function getAlias(): string
    {
        $alias = self::$info['alias'] ?? null;
        return is_string($alias) ? $alias : (string)self::get('alias', '#{PLUGIN_ALIAS}');
    }

    /**
     * {@inheritdoc}
     */
    public static function getVersion(): string
    {
        return (string)self::get('version', '0.0.0');
    }

    /**
     * {@inheritdoc}
     */
    public static function getDescription(): ?string
    {
        $d = self::get('description');
        return is_string($d) ? $d : null;
    }

    /**
     * {@inheritdoc}
     */
    public static function getAuthor(): ?string
    {
        $a = self::get('author');
        return is_string($a) ? $a : null;
    }

    /**
     * {@inheritdoc}
     */
    public static function getUiConfig(): ?array
    {
        $c = self::get('ui');
        return is_array($c) ? $c : null;
    }

    /**
     * {@inheritdoc}
     */
    public static function getHostConfig(): ?array
    {
        $c = self::get('host');
        return is_array($c) ? $c : null;
    }

    /**
     * {@inheritdoc}
     */
    public static function getInfo(): array
    {
        // Ensure a consistent shape.
        return [
            'id' => is_numeric(self::$info['id'] ?? null) ? (int)self::$info['id'] : null,
            'alias' => is_string(self::$info['alias'] ?? null) ? (string)self::$info['alias'] : null,
            'name' => is_string(self::$info['name'] ?? null) ? (string)self::$info['name'] : self::getName(),
        ];
    }

    /**
     * {@inheritdoc}
     */
    public static function getPluginId(): ?int
    {
        $id = self::$info['id'] ?? null;
        return is_numeric($id) ? (int)$id : null;
    }

    /**
     * {@inheritdoc}
     */
    public static function getInstalledAlias(): ?string
    {
        $a = self::$info['alias'] ?? null;
        return is_string($a) ? $a : null;
    }

    /**
     * {@inheritdoc}
     */
    public static function getSignature(): ?string
    {
        if (self::$signature !== null) {
            return self::$signature;
        }
        $p = dirname(__DIR__) . '/.internal/Signed';
        if (!is_file($p)) {
            return self::$signature = null;
        }
        return self::$signature = @file_get_contents($p) ?: null;
    }

    /* ───────────────────────────────────────────────────────────────
     |  Host settings (persisted)
     ─────────────────────────────────────────────────────────────── */

    /**
     * {@inheritdoc}
     */
    public static function getHost(string $key, mixed $default = null): mixed
    {
        $pluginId = self::getPluginId();
        if (!$pluginId) {
            return $default;
        }

        /** @var PluginSetting|null $row */
        $row = PluginSetting::query()
            ->where('plugin_id', $pluginId)
            ->where('key', $key)
            ->first();

        return self::decodeHostSetting($row, $default);
    }

    /* ───────────────────────────────────────────────────────────────
     |  Permissions – list / has / get (via PermissionService)
     ─────────────────────────────────────────────────────────────── */

    /**
     * {@inheritdoc}
     */
    public static function getPermissions(?PermissionListOptions $options = null): PermissionListResult
    {
        $pluginId = self::getPluginId();
        if (!$pluginId) {
            return new PermissionListResult(
                items: [],
                summary: new PermissionListSummary(
                    byType: [],
                    total: 0,
                    active: 0,
                    inactive: 0,
                    requiredTotal: 0,
                    requiredSatisfied: 0,
                    requiredPending: 0
                )
            );
        }

        return Permissions::listPermissions($pluginId, $options ?? new PermissionListOptions());
    }

    /**
     * {@inheritdoc}
     */
    public static function hasPermission(PermissionType|string $type, string $actionOrIntent, array|string|null $meta = null, array $context = []): bool
    {
        $pluginId = self::getPluginId();
        if (!$pluginId) {
            return false;
        }

        $t = $type instanceof PermissionType ? $type->value : (string)$type;
        $target = self::buildTarget($t, $actionOrIntent, $meta);
        if ($target === null) {
            return false;
        }

        $result = self::dispatchCan($t, $pluginId, $actionOrIntent, $target, $context);
        return $result->allowed;
    }

    /**
     * {@inheritdoc}
     */
    public static function getPermission(PermissionType|string $type, string $actionOrIntent, array|string|null $meta = null, array $context = []): Result
    {
        $pluginId = self::getPluginId();
        if (!$pluginId) {
            return Result::deny('plugin_not_installed');
        }

        $t = $type instanceof PermissionType ? $type->value : (string)$type;
        $target = self::buildTarget($t, $actionOrIntent, $meta);
        if ($target === null) {
            return Result::deny('bad_target');
        }

        // Typed dispatch: canDb/canFile/… → Result
        $result = self::dispatchCan($t, $pluginId, $actionOrIntent, $target, $context);

        // If nothing matched, return as-is.
        if ($result->matched === null) {
            return $result;
        }

        // Enrich with matched concrete row via listPermissions() using only allowed options.
        $matchedType = $result->matched->type;
        $matchedId = $result->matched->id;

        $opts = new PermissionListOptions(
            type: $matchedType,
            requiredOnly: null,   // include both required & optional
            activeOnly: null,     // include both active & inactive
            source: 'both',       // include direct and tag
            tagId: null,
            search: null,
            page: null,
            perPage: null
        );

        $list = Permissions::listPermissions($pluginId, $opts);
        $row = self::extractMatchedRow($list, $matchedType, $matchedId);

        if ($row === null) {
            return $result;
        }

        $ctx = $result->context ?? [];
        $ctx['matched_row'] = $row;

        return new Result(
            allowed: $result->allowed,
            reason: $result->reason,
            matched: $result->matched,
            context: $ctx
        );
    }

    /**
     * Locate the concrete row for (type,id) inside a PermissionListResult.
     *
     * The list structure is expected to be:
     *   $list->entries = [
     *     'db' => [ ['id'=>int, 'row'=>array, ...], ... ],
     *     'file' => [ ... ],
     *     ...
     *   ]
     *
     * Returns the 'row' array if present, otherwise the whole entry.
     */
    private static function extractMatchedRow(PermissionListResult $list, string $type, int $id): ?array
    {
        $bucket = $list->entries[$type] ?? null;
        if (is_array($bucket)) {
            foreach ($bucket as $entry) {
                if ((int)($entry['id'] ?? 0) === $id) {
                    return $entry['row'] ?? $entry;
                }
            }
        }

        // Fallback scan (defensive)
        foreach ($list->entries as $entries) {
            if (!is_array($entries)) continue;
            foreach ($entries as $entry) {
                if ((int)($entry['id'] ?? 0) === $id) {
                    return $entry['row'] ?? $entry;
                }
            }
        }

        return null;
    }

    /* ───────────────────────────────────────────────────────────────
     |  Private routing for `can*` calls
     ─────────────────────────────────────────────────────────────── */

    /**
     * Build the target array for a typed `can*` call from flexible meta.
     * Returns null if the shape is insufficient for the requested type.
     *
     * @param string $type
     * @param string $action
     * @param array|string|null $meta
     * @return array<string,mixed>|null
     */
    private static function buildTarget(string $type, string $action, array|string|null $meta): ?array
    {
        switch ($type) {
            case 'db':
                // Accept: ['model'=>...,'columns'=>[]] OR ['table'=>...,'columns'=>[]]
                if (is_array($meta)) {
                    $out = [];
                    if (isset($meta['model'])) $out['model'] = (string)$meta['model'];
                    if (isset($meta['table'])) $out['table'] = (string)$meta['table'];
                    if (isset($meta['columns']) && is_array($meta['columns'])) {
                        $out['columns'] = array_values(array_unique(array_map('strval', $meta['columns'])));
                    }
                    return $out ?: null;
                }
                if (is_string($meta)) {
                    return ['model' => $meta];
                }
                return null;

            case 'file':
                // Must provide baseDir + path explicitly
                if (is_array($meta) && isset($meta['baseDir'], $meta['path'])) {
                    return ['baseDir' => (string)$meta['baseDir'], 'path' => (string)$meta['path']];
                }
                return null;

            case 'notification':
                if (is_array($meta)) {
                    $out = ['channel' => (string)($meta['channel'] ?? '')];
                    if ($out['channel'] === '') return null;
                    if (isset($meta['template'])) $out['template'] = (string)$meta['template'];
                    if (isset($meta['recipient'])) $out['recipient'] = (string)$meta['recipient'];
                    return $out;
                }
                if (is_string($meta)) {
                    return ['channel' => $meta];
                }
                return null;

            case 'module':
                if (is_array($meta) && isset($meta['module'], $meta['api'])) {
                    return ['module' => (string)$meta['module'], 'api' => (string)$meta['api']];
                }
                return null;

            case 'network':
                if (is_array($meta)) {
                    if (!isset($meta['method'], $meta['url'])) return null;
                    return ['method' => strtoupper((string)$meta['method']), 'url' => (string)$meta['url'], 'headers' => $meta['headers'] ?? null];
                }
                if (is_string($meta)) {
                    return ['method' => 'GET', 'url' => $meta];
                }
                return null;

            case 'codec':
                if (is_array($meta) && isset($meta['method'])) {
                    $out = ['method' => (string)$meta['method']];
                    if (isset($meta['options']) && is_array($meta['options'])) {
                        $out['options'] = $meta['options'];
                    }
                    return $out;
                }
                if (is_string($meta)) {
                    return ['method' => $meta];
                }
                return null;

            case 'route':
                if (is_array($meta) && isset($meta['routeId'])) {
                    $out = ['routeId' => (string)$meta['routeId']];
                    if (isset($meta['guard'])) $out['guard'] = (string)$meta['guard'];
                    return $out;
                }
                if (is_string($meta)) {
                    return ['routeId' => $meta];
                }
                return null;

            default:
                return null;
        }
    }

    /**
     * Dispatch to the correct typed `can*` method on the Permissions facade.
     *
     * @param string $type
     * @param int $pluginId
     * @param string $action
     * @param array $target
     * @param array $context
     * @return Result
     */
    private static function dispatchCan(string $type, int $pluginId, string $action, array $target, array $context): Result
    {
        return match ($type) {
            'db' => Permissions::canDb($pluginId, $action, $target, $context),
            'file' => Permissions::canFile($pluginId, $action, $target, $context),
            'notification' => Permissions::canNotify($pluginId, $action, $target, $context),
            'module' => Permissions::canModule($pluginId, $target, $context),
            'network' => Permissions::canNetwork($pluginId, $target, $context),
            'codec' => Permissions::canCodec($pluginId, $target, $context),
            'route' => Permissions::canRouteWrite($pluginId, $target, $context),
            default => Result::deny('unknown_type'),
        };
    }
}